{"meta":{"title":"0Arctic0","subtitle":"Infinite wonders,endless possibilities.","description":"Stop learning useless algotithms,learn how to use binary search.","author":"0Arctic0","url":"https://0Arctic0.github.io","root":"/"},"pages":[{"title":"404","date":"2022-03-02T13:39:14.000Z","updated":"2022-03-02T13:39:42.429Z","comments":true,"path":"/404.html","permalink":"https://0arctic0.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2022-03-02T13:37:51.000Z","updated":"2022-03-03T01:10:12.065Z","comments":false,"path":"categories/index.html","permalink":"https://0arctic0.github.io/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2022-03-02T13:40:42.000Z","updated":"2022-03-02T13:40:51.708Z","comments":true,"path":"gallery/index.html","permalink":"https://0arctic0.github.io/gallery/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-03-02T13:36:42.000Z","updated":"2022-03-03T01:09:35.664Z","comments":false,"path":"tags/index.html","permalink":"https://0arctic0.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一些%你赛题解","slug":"一些-你赛题解","date":"2022-03-08T13:16:50.000Z","updated":"2022-03-08T14:00:47.518Z","comments":true,"path":"2022/03/08/一些-你赛题解/","link":"","permalink":"https://0arctic0.github.io/2022/03/08/%E4%B8%80%E4%BA%9B-%E4%BD%A0%E8%B5%9B%E9%A2%98%E8%A7%A3/","excerpt":"","text":"2022/03/08 #25 T1： 你和别人分别有 viv_ivi​ 气球，但是气球的计数是在模 wi+1w_i+1wi​+1 意义下的。你可以给别人一些气球，问你能获取到的最高排名是多少。 n≤3×105,0≤vi≤wi≤1018n\\leq 3\\times 10^5,0\\leq v_i\\leq w_i\\leq 10^{18}n≤3×105,0≤vi​≤wi​≤1018。 考虑贪心。 排序不亏，我们先按照 viv_ivi​ 为原数组排一遍序，建立一个小根堆，排序原则为让他们的气球数量归零还需要气球的数量。 每次取出堆顶尝试搞破坏，并同时记录当前排名和最小排名，直到不能搞破坏了为止。 时间复杂度：O(nlog⁡n)O(n\\log n)O(nlogn)。 T2: 给一棵树，树上有一些边有有向收费站，第 iii 次经过会收取 2i−12^{i-1}2i−1 元的费用。你一开始在 111 号节点，给一个长度为 kkk 的要经过的点的可重序列，求最小花费。 n≤105,k≤106n\\leq 10^5,k\\leq 10^6n≤105,k≤106。 因为是一棵树，所以路线唯一。我们只需要在 O(n)O(n)O(n) 的时间内快速计算花费即可。 我们做一步转化：把一条路径上的花费转化为处理完所有路径之后对每一条边分别算贡献，而贡献取决于经过这条边的次数，这样就把问题转化为树上链修改，多次单点查询的问题，自然想到用边权下放至点权和树上差分解决。 棘手的是收费站是单向的，所以我们不得不维护两个差分数组，来分别记录根到节点间的上行花费和下行花费。 这样做法就显现出来了：设 k0=1k_0=1k0​=1，对于每条路 (u,v)(u,v)(u,v)，我们分别修改上行差分数组的 uuu 点、下行差分数组的 vvv 点和它们之间的 LCA。处理完所有路径之后，再做 dfs 子树前缀和获得对每条边的贡献，最后累加到答案即可。 T3: 给一棵树怎么又是树，求分别删掉每一条边之后两棵树的最长路较大值的和。 n≤105n\\leq 10^5n≤105。 Trick 题。 我们把这棵树的直径单独拎出来，然后就会形成这样的结构： o-----o-----o------o ...... &lt;-diameter/ \\ / \\ / \\ / \\ &lt;-subtree 盯着这条直径，我们可以想到：如果我们删的边不在直径上，那贡献就是直径的长度———因为树上没有一条路径比它更长。如果我们删的边在直径上，容易发现分裂出来的两棵树的直径的一端依然是原来的端点（否则与直径的定义矛盾）。我们预处理出直径上每个点的子树的最长路，然后做一遍前缀和和后缀和，我们就可以 O(1)O(1)O(1) 查询了。 问题在于，我们搜出来的东西要包括：直径，直径长度，直径上的端点，直径上有序的所有点以及对应边权和边的编号，子树最长路… 子树最长路好处理，在两遍 dfs 里同时求出其余所有信息未免太冗余了… 这时候，我们题目的主人公天天燃出现了，只五分钟就讲出了绝妙的处理方式。 我们直接记录 disdisdis 数组为到直径中一端点的距离，维护 fafafa 数组表示每个节点的唯一父节点。找到另一端点后，我们直接不断跳 fafafa 直到找到前一个端点并把沿途 disdisdis 的值放到数组里。注意到 disdisdis 其实是前缀和，所以我们只需要做一次差分就可以得到原数组！ 高！实在是高！","categories":[],"tags":[{"name":"-模拟赛","slug":"模拟赛","permalink":"https://0arctic0.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}]},{"title":"分块入门入门","slug":"分块入门入门","date":"2022-03-03T02:16:58.000Z","updated":"2022-03-03T08:05:30.846Z","comments":true,"path":"2022/03/03/分块入门入门/","link":"","permalink":"https://0arctic0.github.io/2022/03/03/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8%E5%85%A5%E9%97%A8/","excerpt":"","text":"分块 分块的基本思想大概就是“整块统计，散块暴力”。 如何分块？ 设块长，一般为 n\\sqrt{n}n​，初始化每块的左右边界和每个元素对应的块以及对应的辅助数组。 对于每次区间修改和查询，分「在一块」和「不在一块」两种情况考虑。 LOJ 小分块入门⑨题 区间加，单点询问 维护 addaddadd 数组为整块的加标记。 修改：如果在一块直接按照散块暴力修改，不在一块的话两边的散块也直接暴力，中间的整块直接加在加标记上。 查询：直接返回对应位置的值加上对应块的 addaddadd 标记即可。 区间加，询问区间小于 xxx 的元素个数 对每块维护一个 vector 存储对应块内从小到大排序后的数组。 修改：散块暴力重构 vector，整块直接加在加标记上，因为整块加并不会改变相对大小。 查询：散块暴力扫并统计答案，整块直接在 vector 里二分查找（返回下标）即可。注意传的参要减去对应标记。 区间加，询问区间前驱 依然对每块维护一个 vector 存储对应块内从小到大排序后的数组。 修改：与 2 类似。 查询：散块暴力扫并统计答案，整块直接在 vector 里二分查找（返回对应数）即可。注意找出的值要加上对应标记。 细节：lower_bound 返回不小于 xxx 的第一个值所在的迭代器，所以迭代器要自减一次。另外，它在找不到的时候返回的是尾迭代器，但是这并不代表块内没有对答案的贡献，因为此时 vector 中的最后一个元素也可能是答案。当返回的是首迭代器时及时特判 conitnue。 for(int i=pos[l]+1;i&lt;pos[r];i++)&#123; auto it=lower_bound(sorted[i].begin(),sorted[i].end(),val-add[i]); if(it==sorted[i].begin()) continue; it--; ans=max(ans,(*it)+add[i]); flag=true;&#125; 区间加，区间求和 对每个块维护 sumsumsum 数组表示对应块的元素之和。 修改：与 1 类似。但是在改散块时不要忘记同时维护 sumsumsum。 查询：散块直接暴力加，整块加对应的 addaddadd 标记。注意在统计散块答案的时候不要忘记加散块长度乘上对应块的 addaddadd 标记。 区间开方，区间求和 此题数据范围为 0≤ai≤2310 \\le a_i\\le 2^{31}0≤ai​≤231。 注意到对 000 或 111 开方并不会改变其大小，又因为在本题中一个数最多被开方 666 次，所以我们可以维护一个数组 visvisvis 记录每块是否都被开为 111 或 000。如果 vis=1vis=1vis=1，说明我们没有必要再对此块进行操作。 修改：不管是整块还是散块直接暴力。对于每次修改无标记块内的内容，暴力判断块内是否都为 111 或 000 并决定是否打标记。 查询：与 4 类似，但是不需要额外加 addaddadd 数组。 细节：每次开方先在 sumsumsum 数组里减去原来的值，再把开方后的值加回去。 单点插入，单点询问 模拟块链。感谢 __Xu128 的讲解。 对每个块开一个 vector。 插入：可以在 O(n)O(\\sqrt{n})O(n​) 的时间内定位。当发现某块长度大于 2n2\\sqrt{n}2n​ 时，暴力重构（使用 std::swap 可以在常数时间内完成）。 查询：暴力定位查询即可。 然而并没有代码。 区间乘法，区间加法，单点询问 乍一看：简单题？ 类比某线段树模板题可以猜测我们需要维护一个 addaddadd 数组和 mulmulmul 数组，然后继续类比可以得到先乘再加好写而且精度更高的规律。 直接做？错！ 先对整块打标记再对散块暴力可能会导致答案错误，因为不能确保操作的先后顺序。 所以我们需要一个 pushdown 函数来实现对散块暴力的标记下传，来避免此类问题的出现。 在散块原值有被更改的风险时及时下传并清空标记是正确的。 （pushdown 函数的实现） void pushdown(int x)&#123; for(int i=L[x];i&lt;=R[x];i++) (a[i]=a[i]%MOD*mul[x]%MOD+add[x]%MOD)%=MOD; mul[x]=1,add[x]=0;&#125; （以修改 addaddadd 标记为例） void modify_add(int l,int r,int val)&#123; val%=MOD; if(pos[l]==pos[r]) &#123; pushdown(pos[l]); for(int i=l;i&lt;=r;i++) (a[i]+=val)%=MOD; &#125; else &#123; pushdown(pos[l]),pushdown(pos[r]); for(int i=pos[l]+1;i&lt;pos[r];i++) (add[i]+=val)%=MOD; for(int i=l;i&lt;=R[pos[l]];i++) (a[i]+=val)%=MOD; for(int i=L[pos[r]];i&lt;=r;i++) (a[i]+=val)%=MOD; &#125;&#125; 区间询问等于一个数的元素个数+区间推平（数据随机） 我会珂朵莉树！ 对不起，您被卡常了。 而且我不会珂朵莉树（ 维护一个数组 lazylazylazy 表示这块曾被覆盖过的修改过的数。 推平：散块暴力，整块打标记。考虑到操作的先后顺序我们还需要一个 pushdown 来及时下传标记（类比 7）。 询问：散块暴力，整块如果标记等于询问值就直接加块长，否则暴力。 很暴力。真的非常暴力。 强制在线区间众数（蒲公英） BOSS 题。 设 Sumb,iSum_{b,i}Sumb,i​ 为前 bbb 块中 iii 的出现次数，Numi,jNum_{i,j}Numi,j​ 为从块 iii 到块 jjj 的众数，Cnti,jCnt_{i,j}Cnti,j​ 为从块 iii 到块 jjj 的众数的出现次数。 离散化之后，这三个数组都可以在 O(nn)O(n\\sqrt{n})O(nn​) 的时间内预处理。 容易发现，对于一个区间，可能成为答案的数只有散块中的数和所有整块的区间众数。 分别统计即可。桶的清空可以再遍历一遍散块中的元素做到 O(n)O(\\sqrt n)O(n​)。 注意：使用 unordered_map 会被卡常。你有离散化了为什么还要用这个？ 被卡常的预处理： for(int i=1;i&lt;=block_cnt;i++) &#123; for(int j=1;j&lt;=n;j++) Sum[i][b[j]]=Sum[i-1][b[j]]; for(int j=L[i];j&lt;=R[i];j++) Sum[i][b[j]]++; &#125; for(int i=1;i&lt;=block_cnt;i++) &#123; unordered_map&lt;int,int&gt;m; for(int j=L[i];j&lt;=n;j++) &#123; m[b[j]]++; if(pos[j]!=pos[j+1]) &#123; for(auto k:m) if(Cnt[i][pos[j]]&lt;k.second) Num[i][pos[j]]=k.first,Cnt[i][pos[j]]=k.second; else if(Cnt[i][pos[j]]==k.second &amp;&amp; Num[i][pos[j]]&gt;k.first) Num[i][pos[j]]=k.first; &#125; &#125; &#125; 被卡常的查询： int query(int l,int r)&#123; unordered_map&lt;int,int&gt;m; if(pos[l]==pos[r]) for(int i=l;i&lt;=r;i++) m[b[i]]++; else &#123; for(int i=l;i&lt;=R[pos[l]];i++) m[b[i]]++; for(int i=L[pos[r]];i&lt;=r;i++) m[b[i]]++; for(auto i:m) &#123; int x=i.first; m[x]+=Sum[pos[r]-1][x]-Sum[pos[l]][x]; &#125; if(pos[l]+1&lt;=pos[r]-1 &amp;&amp; !m[Num[pos[l]+1][pos[r]-1]]) m[Num[pos[l]+1][pos[r]-1]]+=Cnt[pos[l]+1][pos[r]-1]; &#125; int num=0,cnt=0; for(auto i:m) &#123; if(cnt&lt;i.second) cnt=i.second,num=i.first; else if(cnt==i.second &amp;&amp; num&gt;i.first) num=i.first; &#125; return dis[num];&#125; 其他好题 P4135 作诗 无修改，多次查询区间出现正偶数次的数的个数。强制在线。 类比 9，我们预处理前缀出现次数和整块区间的答案，这样就可以涵盖所有情况。 散块或无整块区间暴力。 整块直接查表。 还是比较水的… 注意：使用 unordered_map 会被卡常。值域都这么小了为什么还要用这个？ int query(int l,int r)&#123; if(abs(pos[l]-pos[r])&lt;=1) &#123; int ans=0; for(int i=l;i&lt;=r;i++) &#123; M[a[i]]++; if(!(M[a[i]]&amp;1)) ans++; else if(M[a[i]]^1) ans--; &#125; for(int i=l;i&lt;=r;i++) M[a[i]]--; return ans; &#125; else &#123; int ans=Ans[pos[l]+1][pos[r]-1]; for(int i=l;i&lt;=R[pos[l]];i++) &#123; M[a[i]]++; if(!((M[a[i]]+Cnt[pos[r]-1][a[i]]-Cnt[pos[l]][a[i]])&amp;1)) ans++; else if((M[a[i]]+Cnt[pos[r]-1][a[i]]-Cnt[pos[l]][a[i]])^1)ans--; &#125; for(int i=L[pos[r]];i&lt;=r;i++) &#123; M[a[i]]++; if(!((M[a[i]]+Cnt[pos[r]-1][a[i]]-Cnt[pos[l]][a[i]])&amp;1)) ans++; else if((M[a[i]]+Cnt[pos[r]-1][a[i]]-Cnt[pos[l]][a[i]])^1)ans--; &#125; for(int i=l;i&lt;=R[pos[l]];i++) M[a[i]]--; for(int i=L[pos[r]];i&lt;=r;i++) M[a[i]]--; return ans; &#125;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://0arctic0.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分块","slug":"分块","permalink":"https://0arctic0.github.io/tags/%E5%88%86%E5%9D%97/"}]},{"title":"Hello,world!","slug":"Hello-world","date":"2022-03-03T01:03:51.000Z","updated":"2022-03-03T01:10:01.152Z","comments":true,"path":"2022/03/03/Hello-world/","link":"","permalink":"https://0arctic0.github.io/2022/03/03/Hello-world/","excerpt":"","text":"0Arctic0 的 Hexo 博客于 2022 年 3 月 3 日 09:04:56 开始使用！ test: LaTeX\\LaTeXLATE​X qwq qwq qwq 3∗4=12,5∗6=303*4=12,5*6=303∗4=12,5∗6=30 ai≤109,bi≤105a_i\\le 10^9,b_i\\le 10^5ai​≤109,bi​≤105 ∵1+2=3∴1=3−2\\begin{aligned} \\because 1+2=3\\\\ \\therefore 1=3-2 \\end{aligned} ∵1+2=3∴1=3−2​ 使用 vector 方便传参。 #include&lt;iostream&gt;using namespace std;","categories":[],"tags":[{"name":"Test","slug":"Test","permalink":"https://0arctic0.github.io/tags/Test/"}]}],"categories":[],"tags":[{"name":"-模拟赛","slug":"模拟赛","permalink":"https://0arctic0.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"数据结构","slug":"数据结构","permalink":"https://0arctic0.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分块","slug":"分块","permalink":"https://0arctic0.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"Test","slug":"Test","permalink":"https://0arctic0.github.io/tags/Test/"}]}