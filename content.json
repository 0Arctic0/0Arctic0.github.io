{"meta":{"title":"0Arctic0","subtitle":"Infinite wonders,endless possibilities.","description":"Stop learning useless algotithms,learn how to use binary search.","author":"0Arctic0","url":"https://0Arctic0.github.io","root":"/"},"pages":[{"title":"404","date":"2022-03-02T13:39:14.000Z","updated":"2022-03-02T13:39:42.429Z","comments":true,"path":"/404.html","permalink":"https://0arctic0.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2022-03-02T13:37:51.000Z","updated":"2022-03-03T01:10:12.065Z","comments":false,"path":"categories/index.html","permalink":"https://0arctic0.github.io/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2022-03-02T13:40:42.000Z","updated":"2022-03-02T13:40:51.708Z","comments":true,"path":"gallery/index.html","permalink":"https://0arctic0.github.io/gallery/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-03-02T13:36:42.000Z","updated":"2022-03-03T01:09:35.664Z","comments":false,"path":"tags/index.html","permalink":"https://0arctic0.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"分块入门入门","slug":"分块入门入门","date":"2022-03-03T02:16:58.000Z","updated":"2022-03-03T08:05:30.846Z","comments":true,"path":"2022/03/03/分块入门入门/","link":"","permalink":"https://0arctic0.github.io/2022/03/03/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8%E5%85%A5%E9%97%A8/","excerpt":"","text":"分块 分块的基本思想大概就是“整块统计，散块暴力”。 如何分块？ 设块长，一般为 n\\sqrt{n}n​，初始化每块的左右边界和每个元素对应的块以及对应的辅助数组。 对于每次区间修改和查询，分「在一块」和「不在一块」两种情况考虑。 LOJ 小分块入门⑨题 区间加，单点询问 维护 addaddadd 数组为整块的加标记。 修改：如果在一块直接按照散块暴力修改，不在一块的话两边的散块也直接暴力，中间的整块直接加在加标记上。 查询：直接返回对应位置的值加上对应块的 addaddadd 标记即可。 区间加，询问区间小于 xxx 的元素个数 对每块维护一个 vector 存储对应块内从小到大排序后的数组。 修改：散块暴力重构 vector，整块直接加在加标记上，因为整块加并不会改变相对大小。 查询：散块暴力扫并统计答案，整块直接在 vector 里二分查找（返回下标）即可。注意传的参要减去对应标记。 区间加，询问区间前驱 依然对每块维护一个 vector 存储对应块内从小到大排序后的数组。 修改：与 2 类似。 查询：散块暴力扫并统计答案，整块直接在 vector 里二分查找（返回对应数）即可。注意找出的值要加上对应标记。 细节：lower_bound 返回不小于 xxx 的第一个值所在的迭代器，所以迭代器要自减一次。另外，它在找不到的时候返回的是尾迭代器，但是这并不代表块内没有对答案的贡献，因为此时 vector 中的最后一个元素也可能是答案。当返回的是首迭代器时及时特判 conitnue。 for(int i=pos[l]+1;i&lt;pos[r];i++)&#123; auto it=lower_bound(sorted[i].begin(),sorted[i].end(),val-add[i]); if(it==sorted[i].begin()) continue; it--; ans=max(ans,(*it)+add[i]); flag=true;&#125; 区间加，区间求和 对每个块维护 sumsumsum 数组表示对应块的元素之和。 修改：与 1 类似。但是在改散块时不要忘记同时维护 sumsumsum。 查询：散块直接暴力加，整块加对应的 addaddadd 标记。注意在统计散块答案的时候不要忘记加散块长度乘上对应块的 addaddadd 标记。 区间开方，区间求和 此题数据范围为 0≤ai≤2310 \\le a_i\\le 2^{31}0≤ai​≤231。 注意到对 000 或 111 开方并不会改变其大小，又因为在本题中一个数最多被开方 666 次，所以我们可以维护一个数组 visvisvis 记录每块是否都被开为 111 或 000。如果 vis=1vis=1vis=1，说明我们没有必要再对此块进行操作。 修改：不管是整块还是散块直接暴力。对于每次修改无标记块内的内容，暴力判断块内是否都为 111 或 000 并决定是否打标记。 查询：与 4 类似，但是不需要额外加 addaddadd 数组。 细节：每次开方先在 sumsumsum 数组里减去原来的值，再把开方后的值加回去。 单点插入，单点询问 模拟块链。感谢 __Xu128 的讲解。 对每个块开一个 vector。 插入：可以在 O(n)O(\\sqrt{n})O(n​) 的时间内定位。当发现某块长度大于 2n2\\sqrt{n}2n​ 时，暴力重构（使用 std::swap 可以在常数时间内完成）。 查询：暴力定位查询即可。 然而并没有代码。 区间乘法，区间加法，单点询问 乍一看：简单题？ 类比某线段树模板题可以猜测我们需要维护一个 addaddadd 数组和 mulmulmul 数组，然后继续类比可以得到先乘再加好写而且精度更高的规律。 直接做？错！ 先对整块打标记再对散块暴力可能会导致答案错误，因为不能确保操作的先后顺序。 所以我们需要一个 pushdown 函数来实现对散块暴力的标记下传，来避免此类问题的出现。 在散块原值有被更改的风险时及时下传并清空标记是正确的。 （pushdown 函数的实现） void pushdown(int x)&#123; for(int i=L[x];i&lt;=R[x];i++) (a[i]=a[i]%MOD*mul[x]%MOD+add[x]%MOD)%=MOD; mul[x]=1,add[x]=0;&#125; （以修改 addaddadd 标记为例） void modify_add(int l,int r,int val)&#123; val%=MOD; if(pos[l]==pos[r]) &#123; pushdown(pos[l]); for(int i=l;i&lt;=r;i++) (a[i]+=val)%=MOD; &#125; else &#123; pushdown(pos[l]),pushdown(pos[r]); for(int i=pos[l]+1;i&lt;pos[r];i++) (add[i]+=val)%=MOD; for(int i=l;i&lt;=R[pos[l]];i++) (a[i]+=val)%=MOD; for(int i=L[pos[r]];i&lt;=r;i++) (a[i]+=val)%=MOD; &#125;&#125; 区间询问等于一个数的元素个数+区间推平（数据随机） 我会珂朵莉树！ 对不起，您被卡常了。 而且我不会珂朵莉树（ 维护一个数组 lazylazylazy 表示这块曾被覆盖过的修改过的数。 推平：散块暴力，整块打标记。考虑到操作的先后顺序我们还需要一个 pushdown 来及时下传标记（类比 7）。 询问：散块暴力，整块如果标记等于询问值就直接加块长，否则暴力。 很暴力。真的非常暴力。 强制在线区间众数（蒲公英） BOSS 题。 设 Sumb,iSum_{b,i}Sumb,i​ 为前 bbb 块中 iii 的出现次数，Numi,jNum_{i,j}Numi,j​ 为从块 iii 到块 jjj 的众数，Cnti,jCnt_{i,j}Cnti,j​ 为从块 iii 到块 jjj 的众数的出现次数。 离散化之后，这三个数组都可以在 O(nn)O(n\\sqrt{n})O(nn​) 的时间内预处理。 容易发现，对于一个区间，可能成为答案的数只有散块中的数和所有整块的区间众数。 分别统计即可。桶的清空可以再遍历一遍散块中的元素做到 O(n)O(\\sqrt n)O(n​)。 注意：使用 unordered_map 会被卡常。你有离散化了为什么还要用这个？ 被卡常的预处理： for(int i=1;i&lt;=block_cnt;i++) &#123; for(int j=1;j&lt;=n;j++) Sum[i][b[j]]=Sum[i-1][b[j]]; for(int j=L[i];j&lt;=R[i];j++) Sum[i][b[j]]++; &#125; for(int i=1;i&lt;=block_cnt;i++) &#123; unordered_map&lt;int,int&gt;m; for(int j=L[i];j&lt;=n;j++) &#123; m[b[j]]++; if(pos[j]!=pos[j+1]) &#123; for(auto k:m) if(Cnt[i][pos[j]]&lt;k.second) Num[i][pos[j]]=k.first,Cnt[i][pos[j]]=k.second; else if(Cnt[i][pos[j]]==k.second &amp;&amp; Num[i][pos[j]]&gt;k.first) Num[i][pos[j]]=k.first; &#125; &#125; &#125; 被卡常的查询： int query(int l,int r)&#123; unordered_map&lt;int,int&gt;m; if(pos[l]==pos[r]) for(int i=l;i&lt;=r;i++) m[b[i]]++; else &#123; for(int i=l;i&lt;=R[pos[l]];i++) m[b[i]]++; for(int i=L[pos[r]];i&lt;=r;i++) m[b[i]]++; for(auto i:m) &#123; int x=i.first; m[x]+=Sum[pos[r]-1][x]-Sum[pos[l]][x]; &#125; if(pos[l]+1&lt;=pos[r]-1 &amp;&amp; !m[Num[pos[l]+1][pos[r]-1]]) m[Num[pos[l]+1][pos[r]-1]]+=Cnt[pos[l]+1][pos[r]-1]; &#125; int num=0,cnt=0; for(auto i:m) &#123; if(cnt&lt;i.second) cnt=i.second,num=i.first; else if(cnt==i.second &amp;&amp; num&gt;i.first) num=i.first; &#125; return dis[num];&#125; 其他好题 P4135 作诗 无修改，多次查询区间出现正偶数次的数的个数。强制在线。 类比 9，我们预处理前缀出现次数和整块区间的答案，这样就可以涵盖所有情况。 散块或无整块区间暴力。 整块直接查表。 还是比较水的… 注意：使用 unordered_map 会被卡常。值域都这么小了为什么还要用这个？ int query(int l,int r)&#123; if(abs(pos[l]-pos[r])&lt;=1) &#123; int ans=0; for(int i=l;i&lt;=r;i++) &#123; M[a[i]]++; if(!(M[a[i]]&amp;1)) ans++; else if(M[a[i]]^1) ans--; &#125; for(int i=l;i&lt;=r;i++) M[a[i]]--; return ans; &#125; else &#123; int ans=Ans[pos[l]+1][pos[r]-1]; for(int i=l;i&lt;=R[pos[l]];i++) &#123; M[a[i]]++; if(!((M[a[i]]+Cnt[pos[r]-1][a[i]]-Cnt[pos[l]][a[i]])&amp;1)) ans++; else if((M[a[i]]+Cnt[pos[r]-1][a[i]]-Cnt[pos[l]][a[i]])^1)ans--; &#125; for(int i=L[pos[r]];i&lt;=r;i++) &#123; M[a[i]]++; if(!((M[a[i]]+Cnt[pos[r]-1][a[i]]-Cnt[pos[l]][a[i]])&amp;1)) ans++; else if((M[a[i]]+Cnt[pos[r]-1][a[i]]-Cnt[pos[l]][a[i]])^1)ans--; &#125; for(int i=l;i&lt;=R[pos[l]];i++) M[a[i]]--; for(int i=L[pos[r]];i&lt;=r;i++) M[a[i]]--; return ans; &#125;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://0arctic0.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分块","slug":"分块","permalink":"https://0arctic0.github.io/tags/%E5%88%86%E5%9D%97/"}]},{"title":"Hello,world!","slug":"Hello-world","date":"2022-03-03T01:03:51.000Z","updated":"2022-03-03T01:10:01.152Z","comments":true,"path":"2022/03/03/Hello-world/","link":"","permalink":"https://0arctic0.github.io/2022/03/03/Hello-world/","excerpt":"","text":"0Arctic0 的 Hexo 博客于 2022 年 3 月 3 日 09:04:56 开始使用！ test: LaTeX\\LaTeXLATE​X qwq qwq qwq 3∗4=12,5∗6=303*4=12,5*6=303∗4=12,5∗6=30 ai≤109,bi≤105a_i\\le 10^9,b_i\\le 10^5ai​≤109,bi​≤105 ∵1+2=3∴1=3−2\\begin{aligned} \\because 1+2=3\\\\ \\therefore 1=3-2 \\end{aligned} ∵1+2=3∴1=3−2​ 使用 vector 方便传参。 #include&lt;iostream&gt;using namespace std;","categories":[],"tags":[{"name":"Test","slug":"Test","permalink":"https://0arctic0.github.io/tags/Test/"}]}],"categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://0arctic0.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分块","slug":"分块","permalink":"https://0arctic0.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"Test","slug":"Test","permalink":"https://0arctic0.github.io/tags/Test/"}]}